## Нижняя оценка на число ячеек памяти для протокола взаимного исключения

### Теорема (Бернс, Линч)

> Любой проток взаимного исключения для `n` потоков, построенный только на атомарных чтениях и записях, использует по крайней мере `n` ячеек памяти.

#### _Доказательство._

Предположим, работают `n` и есть протокол, который:  
* гарантирует взаимное исключение (ВИ);
* гарантирует свободу от взаимной блокировки (СВБ);
* использует меньше `n` ячеек памяти.  

Никаких других предположений нет. Докажем, что такого протокола не существует.

##### Для `n=2`.  

Даны потоки `T_1`, `T_2` и ячейка памяти `X_1`. Рассмотрим два случая:  
1. пусть поток `T_1` ничего не пишет и заходит в критическую секцию (СВБ). Тогда пришедший поток `T_2` увидет мьютекс в исходном состоянии и также пройдет в критическую секцию. Нарушается ВИ;  
1. пусть поток `T_1` пишет что-то в ячейку `X_1` и планировщик останавливает выполнение потока `T_1` перед его первой записью в `X_1`. После этого пришедший поток `T_2` проходит в критическую секцию (СВБ). Тогда проснувшийся поток `T_1` первый действием уничтожит все следы существования потока `T_2`, записав свое значение в `X_1`. Таким образом, (по СВБ) он проходит в критическую секцию. Нарушается ВИ.

_В обоих случаях получено противоречие, следовательно, для `n=2` теорема доказана._

##### Для `n=3`.

Даны потоки `T_1`, `T_2`, `T_3` и ячейки памяти `X_1`, `X_2`. Ясно, что каждый поток что-то пишет хотя бы в одну из ячеек памяти. Рассмотрим такую конфигурацию, что `T_1` и `T_2` остановлены перед своими первыми записями в `X_1` и `X_2` соответственно (без потери общности), причем ячейки `X_1` и `X_2` содержат начальные значения. Пусть поток `T_3` проходит в критическую секцию. Далее `T_1` делает свою запись в `X_1`, затем `T_2` делает свою запись в `X_2`. Таким образом, стерты все следы существования потока `T_3`. Тогда (по СВБ) один из потоков `T_1`, `T_2` проходит в критическую секцию. Нарушается ВИ.

Докажем, что описанную конфигурацию всегда можно получить. Пусть поток `T_1` выполняет следующие операции: `mutex.lock() -> mutex.unlock() -> mutex.lock() -> mutex.unlock() -> mutex.lock() -> mutex.lock()`. Так как методов `lock()` вызвано три, а ячеек памяти две, то по принципу Дирихле в одну из ячеек памяти первая запись осуществлена дважды. Пусть для определенности эти записи в ячейку `X_1` на первой и третьей итерации.

Остановим поток `T_1` перед его первой записью в `X_1` на первой итерации. Далее запускаем поток `T_2`: ясно, что он пишет что-то в ячейку `X_2` (по доказанному для `n=2`). Остановим его перед первой записью в ячейку `X_2`. (Возможно, он при этом что-то записал в `X_1`!) Далее запускаем поток `T_1` и останавливаем его перед первой записью в ячейку `X_1` на третьей итерации. По построению это первая запись потока `T_1`, то есть значение `X_2` начальное: был вызван метод `unlock()`. Таким образом, `T_1` остановлен перед первой записью в `X_1`, `T_2` остнановлен перед первой записью в `X_2`. _Искомая конфигурация получена, что и доказывает теорему для `n=3`._

##### Для произвольного `n`.

Докажем утверждение индукцией по `n`. База рассмотрена выше. Далее везде считаем, что для меньшего, чем `n`, числа потоков, теорема доказана.

Даны потоки `T_1`, `T_2`, …, `T_[n+1]` и ячейки памяти `X_1`, `X_2`, …, `X_n`. Ясно, что каждый поток что-то пишет хотя бы в одну из ячеек памяти. Рассмотрим такую конфигурацию, что `T_1`, `T_2`, …, `T_n` остановлены перед своими первыми записями в `X_1`, `X_2`, …, `X_n` соответственно (без потери общности), причем ячейки `X_1`, `X_2`, …, `X_n` содержат начальные значения. Пусть поток `T_[n+1]` проходит в критическую секцию. Далее `T_1` делает свою запись в `X_1`, затем `T_2` делает свою запись в `X_2`, …, затем `T_n` делает свою запись в `X_n`. Таким образом, стерты все следы существования потока `T_[n+1]`. Тогда (по СВБ) один из потоков `T_1`, `T_2`, …, `T_n` проходит в критическую секцию. Нарушеается ВИ.

Докажем, что описанную конфигурацию всегда можно получить, индукцией по числу потоков.

_Утверждение._ Пусть `1<=k<=n`.  Тогда существует конфигурация, когда `T_1`, `T_2`, …, `T_k` остановлены перед своими первыми записями в разные `k` ячеек памяти, причем все ячейки памяти содержат начальные значения.

База при `k=1` очевидна.  


Пусть теперь `k > 1`. По предположению индукции возможно получить конфигурацию, когда `T_1`, `T_2`, …, `T_k` пишут в разные `k` ячеек памяти. Обозначим через `ConfigureThreads()` последовательность операций, приводящую к такой конфигурации. Из `k` потоков в `k` ячеек памяти из `n` возможных существует `C[n,k]` различных отображений. Тогда пусть потоки выполняют `ConfigureThreads() -> ConfigureThreads() -> … -> ConfigureThreads()` всего `C[n,k]+1` раз. По принципу Дирихле найдется такие две `ConfigureThreads()`, которые делают одно и то же соответствие между `T_1`, `T_2`, …, `T_k` и `k` ячейками памяти. Пусть для определенности это первый и последний вызов `ConfigureThreads()`, а запись осуществела в ячейки памяти `X_1`, `X_2`, …, `X_k` соответственно.

Рассмотрим найденное выполение операций `ConfigureThreads() -> …`. Остановим потоки в рассмотренной выше конфигурации. Далее запустим `T_[k+1]`. Ясно, что он пишет что-то в какую-то из ячеек `X_[k+1]`, …, `X_n` (по предположению индукции для меньшего `n`). Остановим его перед первой записью в какую-то из этих ячеек. (Возможно, он при этом что-то записал в какие-то из ячеек `X_1`, …, `X_k`!) Далее запускаем наши `ConfigureThreads()` и останавливаем их перед своими первыми записями в `X_1`, …, `X_k` на последней итерации. По построению ячейки `X_[k+1]`, …, `X_n` содержат начальные значения. Таким образом, потоки `T_1`, …, `T_k`, `T_[k+1]` остановлены перед своими первыми записями в разные `k+1` ячеек памяти. _Утверждение доказано._

_Значит, искомая конфигурация существует для `k=n`, что и доказывает теорему в общем случае._

#### Замечания.

* Каждый метод `lock()` не обязан требовать обращения ко всем `n` ячейкам памяти. Например, в турнирном дереве мьютексов один вызов обращается к `O(log(n))` ячейкам.  
* Для построения противоречия мы не использовали никаких предположений о разрядности ячеек памяти.  
* Доказательство работает даже для случая недетерминированного исполнения.  
* Доказательство не работает, если используется операция `exchange()`: с ее помощью можно атомарно менять значение в ячейке памяти и читать старое значение, на основании которого делать выводы о наличии других потоков.  
* Каждый `ConfigureThreads()` для `k` потоков построен с помощью `C[n,k-1]+1` операций `ConfigureThreads()` для `k-1` потоковю. Таким образом, для построения «плохого исполнения» в случае `n` потоков используется экспоненциальное число операций (сумма биномиальных коэффициентов).
